package pl.edu.mimuw.nesc.plugin.wizards;

import pl.edu.mimuw.nesc.plugin.NescPlugin;
import pl.edu.mimuw.nesc.plugin.editor.NescEditor;
import pl.edu.mimuw.nesc.plugin.preferences.NescPluginPreferences;
import pl.edu.mimuw.nesc.plugin.preferences.NescPreferencesInitializer;
import pl.edu.mimuw.nesc.plugin.projects.util.CommentGroupWrapper;
import pl.edu.mimuw.nesc.plugin.projects.util.NescProjectPreferences;

import com.google.common.base.Optional;

import java.io.PrintWriter;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Arrays;

import org.eclipse.core.resources.IContainer;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IWorkspaceRoot;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.jface.resource.ImageDescriptor;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.ui.IEditorInput;
import org.eclipse.ui.IEditorPart;
import org.eclipse.ui.IFileEditorInput;
import org.eclipse.ui.IWorkbenchPage;
import org.eclipse.ui.IWorkbenchWindow;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.part.FileEditorInput;
import org.eclipse.ui.texteditor.ITextEditor;

/**
 * Class that follows the utility design pattern. It contains operations that
 * are common for wizards.
 *
 * @author Micha≈Ç Ciszewski <michal.ciszewski@students.mimuw.edu.pl>
 */

class NescWizardSupport {
    /**
     * Number of spaces in content generated by wizards that create a single
     * indentation step.
     */
    private static final int INDENTATION_SIZE = 4;

    /**
     * Constant with the character that creates indentation. It is obviously
     * a space.
     */
    private static final char INDENTATION_CHAR = ' ';

    /**
     * String that contains exactly a single indentation step in the content
     * generated by wizards.
     */
    private static String indentationStep;

    /**
     * Extension of nesC source files (with the dot).
     */
    static final String NESC_SOURCE_EXTENSION = ".nc";

    /**
     * @return String with whitespace that create exactly a single indentation
     *         step.
     */
    static String getIndentationStep() {
        if (indentationStep == null) {
            char[] indentStepCharArray = new char[INDENTATION_SIZE];
            Arrays.fill(indentStepCharArray, INDENTATION_CHAR);
            indentationStep = new String(indentStepCharArray);
        }

        return indentationStep;
    }

    /**
     * Opens a nesC editor for the file given by argument. The cursor in the
     * editor is set to the given position. If the operation fails and
     * <code>parent</code> and <code>errMsg</code> are not null, a message
     * dialog is shown with this message.
     *
     * @param file File to show in the editor.
     * @param cursorOffset Position of the cursor in the editor to set.
     * @param parent Shell that will be used as the parent for the message
     *               dialog if an error happens.
     * @param errMsg Message that will be shown if the operation fails.
     */
    static void openEditor(IFile file, int cursorOffset, Shell parent, String errMsg) {
        try {
            // Open the editor with the file
            final IEditorInput editorInput = new FileEditorInput(file);
            final IWorkbenchWindow activeWnd = PlatformUI.getWorkbench().getActiveWorkbenchWindow();
            final IWorkbenchPage activePage = activeWnd.getActivePage();
            final IEditorPart editorPart = activePage.openEditor(editorInput,
                    NescEditor.EDITOR_ID);

            // Set the cursor properly
            try {
                if (editorPart instanceof ITextEditor) {
                    final ITextEditor textEditor = (ITextEditor) editorPart;
                    textEditor.selectAndReveal(cursorOffset, 0);
                }
            } catch(Exception e) {
                // exceptions in this part are ignored
            }
        } catch(Exception e) {
            if (parent != null && errMsg != null) {
                final MessageDialog dialog = new MessageDialog(parent, "Information", null,
                    errMsg, MessageDialog.INFORMATION, new String [] { "OK" }, 0);
                dialog.open();
            }
        }
    }

    /**
     * @return The initial source folder for a wizard or empty string if it
     *         cannot be obtained.
     */
    static String getInitialSourceFolderFullPath() {
        String result = getSelectedContainerFullPath();
        if ("".equals(result)) {
            result = getActiveEditorContainerFullPath();
        }

        return result;
    }

    /**
     * @return Full path of the currently selected project by the user in the
     *         package explorer. If an error happens, empty string ("") is
     *         returned.
     */
    static String getSelectedContainerFullPath() {
        // Get the active window
        final IWorkbenchWindow activeWnd = PlatformUI.getWorkbench().getActiveWorkbenchWindow();
        if (activeWnd == null) {
            return "";
        }

        // Get the selection
        final ISelection selection = activeWnd.getSelectionService().getSelection();
        if (!(selection instanceof IStructuredSelection)) {
            return "";
        }
        final IStructuredSelection structSelection = (IStructuredSelection) selection;

        // Get the selected element and examine it
        final Object selected = structSelection.getFirstElement();
        if (!(selected instanceof IAdaptable)) {
            return "";
        }
        final IAdaptable selectedAdaptable = (IAdaptable) selected;
        final IContainer curContainer = (IContainer) selectedAdaptable.getAdapter(IContainer.class);
        if (curContainer == null) {
            return "";
        }

        return curContainer.getFullPath().toString();
    }

    /**
     * @return Full path to the container of the file in the currently opened
     *         tab. If the operation fails, empty string is returned.
     */
    static String getActiveEditorContainerFullPath() {
        // Get active window
        final IWorkbenchWindow activeWnd = PlatformUI.getWorkbench().getActiveWorkbenchWindow();
        if (activeWnd == null) {
            return "";
        }

        // Examine currently opened file
        final IWorkbenchPage activePage = activeWnd.getActivePage();
        if (activePage == null) {
            return "";
        }
        final IEditorPart editorPart = activePage.getActiveEditor();
        if (editorPart == null) {
            return "";
        }
        final IEditorInput editorInput = editorPart.getEditorInput();
        if (!(editorInput instanceof IFileEditorInput)) {
            return "";
        }
        final IFileEditorInput fileEditorInput = (IFileEditorInput) editorInput;
        final IContainer parent = fileEditorInput.getFile().getParent();
        if (parent == null) {
            return "";
        }

        return parent.getFullPath().toString();
    }

    /**
     * @param internalPath Path inside the plug-in to the resource. It should not
     *                     be absolute and start with a slash.
     * @return URL to the plug-in resource indicated by the given path.
     * @throws MalformedURLException The generated URL is invalid.
     */
    static URL getPluginResourceURL(String internalPath) throws MalformedURLException {
        return new URL("platform:/plugin/Nesc_Plugin/" + internalPath);
    }

    /**
     * Creates and returns an image descriptor for the image in the location
     * specified by the given path. It should be a path of a plug-in resource.
     *
     * @param imagePath Path of a plug-in resource with an image.
     * @return Image descriptor object for the given image or null if an error
     *         happens (e.g. the resource is absent).
     */
    static ImageDescriptor getImageDescriptorForResource(String imagePath) {
        try {
            final URL imageURL = getPluginResourceURL(imagePath);
            return ImageDescriptor.createFromURL(imageURL);
        } catch (MalformedURLException e) {
            return null;
        }
    }

    /**
     * Tries to find the project that is indicated by the given path.
     *
     * @param fullPath A string with an absolute path to an Eclipse resource.
     * @return IProject object that is indicated by the given path or null if
     *         such project cannot be found (wrapped by Optional).
     * @throws NullPointerException Given argument is null.
     * @throws IllegalArgumentException Given path is empty.
     */
    static Optional<IProject> getProjectFromFullPath(String fullPath) {
        // Check argument
        if (fullPath == null) {
            throw new NullPointerException("full path cannot be null");
        } else if (fullPath.isEmpty()) {
            throw new IllegalArgumentException("full path cannot be empty");
        }

        // Extract the project name from the path
        final String withoutSlash =   fullPath.startsWith("/")
                                    ? fullPath.substring(1)
                                    : fullPath;
        final int slashPosition = withoutSlash.indexOf('/');
        final String projectName =   slashPosition != -1
                                   ? withoutSlash.substring(0, slashPosition)
                                   : withoutSlash;

        // Try to get the project
        final IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();
        final IResource resource = root.findMember(projectName, false);

        return   resource instanceof IProject
               ? Optional.of((IProject) resource)
               : Optional.<IProject>absent();
    }

    /**
     * Generates and unconditionally writes the head and entity comments to
     * given stream. The project settings that affect the comments generation
     * are taken from the preferences of the project that is on the given path.
     */
    static void writeComments(String newFileFullPath, PrintWriter out) {
        final Optional<IProject> maybeProject = getProjectFromFullPath(newFileFullPath);

        // Head comment
        final String headComment = generateHeadComment(maybeProject);
        if (!headComment.isEmpty()) {
            out.println(headComment);
            out.println();
            out.println();
        }

        // Entity comment
        final String entityComment = generateEntityComment(maybeProject);
        if (!entityComment.isEmpty()) {
            out.println(entityComment);
        }
    }

    /**
     * @return String with comment that is to be placed in the top part of
     *         a file that is created by a wizard if the user chooses such
     *         option. It does not contain any newline character after or before
     *         the comment text. If the comment should not be placed, the empty
     *         string is returned.
     */
    static String generateHeadComment(Optional<IProject> maybeProject) {
        return generateCommentGeneric(maybeProject, NescProjectPreferences.COMMENT_HEAD,
                    NescPluginPreferences.HEAD_COMMENT,
                    NescPreferencesInitializer.getDefaultHeadComment());
    }

    /**
     * @return String with comment that is to be placed exactly before an
     *         interface or component definition. It does not contain any
     *         newline character before or after the comment text. If the
     *         comment should not be placed, the empty string is returned.
     */
    static String generateEntityComment(Optional<IProject> maybeProject) {
        return generateCommentGeneric(maybeProject, NescProjectPreferences.COMMENT_ENTITY,
                    NescPluginPreferences.ENTITY_COMMENT,
                    NescPreferencesInitializer.getDefaultEntityComment());
    }

    /**
     * @return The comment that is set in the preferences of the given project.
     *         The value is absent if and only if the project is absent or the
     *         comment is to be inherited from global preferences.
     */
    private static Optional<String> getCommentFromProjectPreferences(Optional<IProject> maybeProject,
            String projectPreferenceName) {
        if (maybeProject.isPresent()) {
            final CommentGroupWrapper.Setting commentSetting =
                    CommentGroupWrapper.Setting.loadFromProjectPreferences(
                            maybeProject.get(),
                            projectPreferenceName
                    );

            class ReadVisitor implements CommentGroupWrapper.Setting.Visitor {
                private boolean inherit;
                private String result;

                @Override
                public void visit(CommentGroupWrapper.Inherit marker) {
                    inherit = true;
                }

                @Override
                public void visit(CommentGroupWrapper.DontGenerate marker) {
                    inherit = false;
                    result = "";
                }

                @Override
                public void visit(CommentGroupWrapper.ProjectSpecific marker) {
                    result = marker.getComment().trim();
                    inherit = result.isEmpty();
                }
            }

            final ReadVisitor visitor = new ReadVisitor();
            commentSetting.accept(visitor);
            if (!visitor.inherit) {
                return Optional.of(visitor.result);
            }
        }

        return Optional.absent();
    }

    /**
     * Retrieve the comment to use when creating new files.
     *
     * @param maybeProject Project whose preferences contain the setting for
     *                     comment that will be used.
     * @param projectPreferenceName Name of the preference of the given project
     *                              to read the comment setting from.
     * @param preferenceName Name of the global preference to read the comment
     *                       if the project preferences say to inherit the
     *                       comment.
     * @param valueIfEmpty Value that will be returned if the found comment is
     *                     empty (if it is set not to be generated, the empty
     *                     string is returned).
     * @return String with comment to be used. It depends on the project and
     *         global preferences. If no comment is to be used, the empty string
     *         is returned. If the determined comment is empty, then
     *         <code>valueIfEmpty</code> is returned.
     */
    private static String generateCommentGeneric(Optional<IProject> maybeProject,
            String projectPreferenceName, String preferenceName, String valueIfEmpty) {
        // Try to get the setting from the project preferences
        final Optional<String> maybeComment = getCommentFromProjectPreferences(maybeProject,
                projectPreferenceName);
        if (maybeComment.isPresent()) {
            return maybeComment.get();
        }

        // The comment must be inherited from global preferences so do it
        final IPreferenceStore store = NescPlugin.getDefault().getPreferenceStore();
        final String preferredValue = store.getString(preferenceName).trim();
        return   !preferredValue.isEmpty()
               ? preferredValue
               : valueIfEmpty.trim();
    }
}
